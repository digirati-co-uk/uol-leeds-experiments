using Fedora.Abstractions;
using Microsoft.AspNetCore.Mvc;
using Storage;
using Preservation.API.Data;
using Preservation.API.Data.Entities;
using Preservation.API.Models;
using Preservation.API.Services;
using Preservation.API.Services.ImportJobs;
using Utils;

namespace Preservation.API.Controllers;

[Route("deposits/{id}/[controller]")]
[ApiController]
public class ImportJobsController(
    PreservationContext dbContext,
    IStorage storage,
    IImportJobQueue importJobQueue,
    IImportService importService,
    IIdentityService identityService,
    ModelConverter modelConverter) : Controller
{
    /// <summary>
    /// Generate an ImportJob - a statement, in JSON form, of what changes you want carried out.
    /// Containers to add, Containers to delete, Binaries to add, Binaries to delete, Binaries to update.
    /// This will build an ImportJob for you, by comparing the DigitalObject (if it exists) with the content of the
    /// Deposit in S3 (**S3 only - production implementation will use any known METS files for further metadata and
    /// structure**).
    /// No changes will be made at this point. The ImportJob can be manually edited prior to submission if required.
    /// </summary>
    /// <param name="id">The identifier of a deposit to generate ImportJob for</param>
    /// <returns>JSON object representing changeset</returns>
    [HttpGet("diff")]
    [Produces("application/json")]
    [Produces<PreservationImportJob>]
    public async Task<IActionResult> GenerateImportJob([FromRoute] string id, CancellationToken cancellationToken)
    {
        var existingDeposit = await dbContext.Deposits.GetDeposit(id, cancellationToken);
        var validationResult = ValidateDeposit(existingDeposit);
        if (validationResult != null) return validationResult;

        var preservationImportJob = await GenerateDiffImportJob(id, existingDeposit);
        return Ok(preservationImportJob);
    }

    private async Task<PreservationImportJob?> GenerateDiffImportJob(string id, DepositEntity existingDeposit)
    {
        var start = DateTime.UtcNow;
        // TODO - handle versions

        // Get the as-is view from storage-api
        var existingArchivalGroup = await GetExistingArchivalGroup(existingDeposit);

        // is PreservationPath correct here? Does it need to be the fcrepo/ path, or derived from that at least?
        // I don't think so - the consumer of the PreservationAPI shouldn't ever know that path, we can rewrite on execute
        // but should that happen here or in StorageAPI? Doing it here for now
        var importJob = await importService.GetImportJob(
            existingArchivalGroup,
            existingDeposit.S3Root,
            existingDeposit.PreservationPath,
            start,
            false,
            true);

        // This importJob has only been generated by diff from the S3 source.
        // If there were checksums in S3, they will have been added to the Digest fields.
        // The Preservation API has additional sources - it can find the METS File.
        // await importService.EmbellishFromMets(importJob, existingArchivalGroup);
        if (string.IsNullOrEmpty(importJob.ArchivalGroupName))
        {
            importJob.ArchivalGroupName = importJob.ArchivalGroupUri!.Slug();
        }

        var preservationImportJob = modelConverter.ToPreservationResource(importJob, id);
        return preservationImportJob;
    }


    /// <summary>
    /// Execute the instructions in the provided ImportJob JSON to create/update/delete relevant resources in
    /// underlying preservation storage.
    /// This will quickly return an empty ImportJobResult in the "waiting" state. The "id" property and returned
    /// Location header will link to a location where the status of import can be checked  
    /// </summary>
    /// <param name="id">The deposit Id this is related to</param>
    /// <param name="importJob">JSON instructions to be carried out</param>
    /// <param name="cancellationToken"></param>
    /// <returns>Newly created ImportJobResult</returns>
    [HttpPost]
    [Produces("application/json")]
    [ProducesResponseType<ImportJobResult>(201, "application/json")]
    public async Task<IActionResult> ExecuteImportJob([FromRoute] string id, [FromBody] PreservationImportJob importJob,
        CancellationToken cancellationToken)
    {
        // TODO - take a PreservationImportJob?
        var existingDeposit = await dbContext.Deposits.GetDeposit(id, cancellationToken);
        var validationResult = ValidateDeposit(existingDeposit);
        if (validationResult != null) return validationResult;

        // Special case https://github.com/uol-dlip/docs/blob/main/rfcs/003-preservation-api.md#execute-import-job
        // Do the diff and the job in one step
        if (IsPostedDiffReference(importJob, Request.Path))
        {
            importJob = await GenerateDiffImportJob(id, existingDeposit);
        }

        importJob.DigitalObject =
            ArchivalGroupUriHelpers.GetArchivalGroupRelativePath(existingDeposit.PreservationPath)!;
        
        // Create a new identity
        var entity = new ImportJobEntity
        {
            Id = await identityService.MintImportJobIdentity(cancellationToken),
            OriginalImportJobId = importJob.Id!,
            Deposit = id,
            ImportJobJson = modelConverter.GetImportJson(importJob),
            DigitalObject = existingDeposit.PreservationPath,
            // DigitalObjectName = importJob.DigitalObjectName // should add this to the entity
        };
        dbContext.ImportJobs.Add(entity);
        await dbContext.SaveChangesAsync(cancellationToken);
        
        // queue up for processing
        await importJobQueue.QueueRequest(entity, cancellationToken);
        
        // convert entity to ImportJobResult
        var importJobResult = modelConverter.ToImportJobResult(entity);

        return CreatedAtAction(nameof(GetImportJobResult), new { id, importJobId = entity.Id }, importJobResult);
    }

    private bool IsPostedDiffReference(PreservationImportJob importJob, PathString path)
    {
        // This is when the API caller posts a reference to the diff import job rather than an _actual_ job
        // means we have to build the diff now.
        if(importJob.Id!.ToString().EndsWith(path + "/diff"))
        {
            // We may want to be more flexible that this, e.g., allowing the DigitalObject to be set as part of the immediate diff execution
            if(    importJob.Deposit == null 
                && importJob.DigitalObject == null
                && importJob.DigitalObjectName == null
                && importJob.ContainersToAdd == null || importJob.ContainersToAdd.Length == 0
                && importJob.ContainersToDelete == null || importJob.ContainersToDelete.Length == 0
                && importJob.BinariesToAdd == null || importJob.BinariesToAdd.Length == 0
                && importJob.BinariesToDelete == null || importJob.BinariesToDelete.Length == 0
                && importJob.BinariesToPatch == null || importJob.BinariesToPatch.Length == 0)
            {
                return true;
            }
        }
        return false;
    }

    /// <summary>
    /// Get the status of an existing ImportJobResult - the result of executing an ImportJob
    /// </summary>
    /// <param name="id">Deposit id import job is for</param>
    /// <param name="importJobId">Unique import job identifier</param>
    /// <returns>Status of ImportJobResult</returns>
    [HttpGet("results/{importJobId}")]
    public async Task<IActionResult> GetImportJobResult([FromRoute] string id, [FromRoute] string importJobId,
        CancellationToken cancellationToken)
    {
        var entity = await dbContext.ImportJobs.GetImportJob(importJobId, cancellationToken);
        if (entity == null || !entity.Deposit.Equals(id, StringComparison.OrdinalIgnoreCase)) return NotFound();
        
        var importJobResult = modelConverter.ToImportJobResult(entity);
        return Ok(importJobResult);
    }

    private IActionResult? ValidateDeposit(DepositEntity? existingDeposit)
    {
        if (existingDeposit == null) return NotFound();
        if (existingDeposit.IsBeingExported()) return BadRequest("Deposit is being exported");
        if (existingDeposit.PreservationPath == null) return BadRequest("Deposit requires DigitalObject");
        return null;
    }

    private async Task<ArchivalGroup?> GetExistingArchivalGroup(DepositEntity existingDeposit)
    {
        var path = ArchivalGroupUriHelpers.GetArchivalGroupPath(existingDeposit.PreservationPath);
        var storageResource = await storage.GetArchivalGroup(path, null);
        return storageResource;
    }
}